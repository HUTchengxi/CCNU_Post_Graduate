## 邻接表存储图
```
/*邻接表结构*/
typedef char VertexType;     //顶点类型 
typedef int EdgeType;		//权值类型 
 
/*边表结点*/ 
typedef struct EdgeNode
{
	int adjvex;      	 	//邻接点域,保存邻接点下标    
	EdgeType weight;		//存储权值，非网图则不需要 
	struct EdgeNode *next;	//链域，指向下一个邻接点 
}EdgeNode;
 
typedef struct VertexNode
{
	VertexType data;       	//顶点域 
	EdegeNode *firstedge;	//边表头指针	
}VertexNode,AdList[MAX];
 
typedef struct
{
	AdjList adjList;
	int numVertexes,numEdges;    //顶点数量和边数量 
}GraphAdjList,*GraphAdj; 
```

## BFS
### 非递归形式：利用队列的先进先出原则
```
/*广度优先遍历*/
void BFS(GraphAdj G){
	
	Queue *Q =(LQueue)malloc(sizeof(Queue));
	for(int i = 0; i < G->numVertexes; i++){
		visited[i] = FALSE;
	}
	InitQueue(Q);  // 初始化队列为空
	for(int i = 0; i < G->numVertexes; i++){
		visited[i] = TRUE;
		printf("\t%c", G->adjList[i].data);
		EnQueue(Q, i); // 入队
		
		while(!QueueisEmpty(Q)){
			DeQueue(Q, &i);  //出队 
			EdgeNode *e = G->adjList[i].firstedge;  //i顶点的邻接链表的第一个结点
			while(e){//e存在时，将e的所有邻接点加入队列,也就是遍历i的所有邻接点 
				if(!visited[e->adjvex]){ // adjvex是e所表示的结点下标 
					visited[e->adjvex] = TRUE;
					printf("\t%c", G->adjList[e->adjvex].data);
					EnQueue(Q, e->adjvex); //将该结点入队 
				}
				e = e->next; //遍历i的下一个邻接点 
			}
		} 
	}
} 
```

## DFS
### 非递归形式：利用栈的先进后出原则
```
void FDFS(AdjGraph *G, int v)//非递归算法
{
	Sqstack *s;
	InitStack(s);
	ArcNode *e;
	ArcNode *q;
	Push(s,G->adjlist[v].firstarc);//将元素v的邻接点的地址（即v指向邻接点的指针）压入栈中
	visited[v] = 1;//记v被访问过
	printf("%d ", v);
	while (!EmptyStack(s))//栈是否为空
	{
		GetPop(s,q);//取栈顶元素
			while (q!=NULL)
			{
				if (visited[q->adjvex] == 0)//如果该邻接点没被访问过
				{
					visited[q->adjvex] = 1;
					printf("%d ", q->adjvex);
					Push(s,G->adjlist[q->adjvex].firstarc);//将该邻接点指向的指针压入栈中
					break;
				}
				else//如果该点被访问过，即已经打印出来了
				{
					q = q->nextarc;//q指向当前的下个邻接点
					if (q == NULL)//意味着在当前元素的邻接点都被访问过了
						Pop(s, e);//pop出来
				}
			};
	}
	while (s->top > -1)
	{
		Pop(s,e);
		printf("%d ", e->adjvex);
	}
	DestroStack(s);
}
```
### 递归形式
```
/*邻接表的深度优先递归*/
void DFS(GraphAdj G,int i)
{
	EdgeNode *p;
	visited[i]=TRUE;         		//访问过了该顶点，标记为TRUE 
	printf("%c",G->adjList[i].data);
	p=G->adjList[i].firstedge;     //让p指向边表第一个结点 
	while(p)                      //在边表内遍历 
	{
		if(!visited[p->adjvex])    //对未访问的邻接顶点递归调用 
			DFS(G,p->adjvex);    
		p=p->next;
	}
 } 
 
 //邻接表的深度遍历操作
 
void DFSTraverse(GraphAdj G)
{
	int i;
	for(i=0;i<G->numVertexes;i++)
		visited[i]=FALSE;         //初始设置为未访问?
	for(i=0;i<G->numVertexes;i++)
		if(!visited[i])
			DFS(G,i);	//对未访问的顶点调用DFS，若是连通图只会执行一次?			
} 
```