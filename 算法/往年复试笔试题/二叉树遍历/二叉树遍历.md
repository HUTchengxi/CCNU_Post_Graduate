## 先序遍历、中序遍历和后序遍历
### 递归代码
```
//定义visit函数
void visit (BiTree T){
    printf("%c",T->data);
}

//先序遍历
void PreOrder(BiTree T){
    if(T!=null){
        visit(T);
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}

// 中序遍历
void InOrder(BiTree T){
    if(T!=null){
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}

//后序遍历
void PostOrder(BiTree T){
    if(T!=null){
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
}
```
### 非递归实现
```
#define null 0
#define Elemtype char
#define elemtype BiTree
#define maxsize 30
#define false 0
#define true 1
#define bool int
typedef struct BiNode{
    Elemtype data;
    struct BiNode *lchild,*rchild;
}BiNode,*BiTree;

typedef struct {
    elemtype data[maxsize];
    int top;
}sqstack;
//初始化栈
void initStack(sqstack *s){
    s->top = -1;
}
//判断栈空 如果stack是空的 则返回true 否则返回 false
bool empty_stack(sqstack s){
    if(s.top == -1){
        return true;
    }else{
        return false;
    }
}
//入栈
void Push(sqstack *s,BiTree p){
        if(s->top == maxsize-1){
        printf("this stack is full");
    }
    else{
        s->data[++(s->top)]= p;
    }
}
//出栈
void Pop(sqstack *s,BiTree *p){
    if(s->top == -1){
        printf("this stack is null!");
    }else{
        *p = s->data[(s->top)--];
    }
}
//获取栈顶元素
void getTop(sqstack s,BiTree *p){
    *p = s.data[s.top];
}

//定义visit函数
void visit (BiTree T){
    printf("%c",T->data);
}

//中序遍历
void InOrder2(BiTree T){
    sqstack s;
    initStack(&s);
    BiTree p=T; //p是遍历指针
    while(p||!empty_stack(s)){
        if(p){
            Push(&s,p);
            p=p->lchild;
        }
        else{
            Pop(&s,&p);
            visit(p);
            p=p->rchild;
        }
    }

}

//先序遍历（非递归算法）
      //与中序的区别就是把visit操作放在了push前面
void PreOrder2(BiTree T){
    sqstack s;
    initStack(&s);
    BiTree p=T; //p是遍历指针
    while(p||!empty_stack(s)){
        if(p){
            visit(p);
            Push(&s,p);
            p=p->lchild;
        }
        else{
            Pop(&s,&p);
            p=p->rchild;
        }
    }

}

//后序遍历（非递归算法）
void PostOrder2(BiTree T){
    sqstack s;
    initStack(&s);
    BiTree p = T;
    BiNode *r = null;   //r指针为辅助指针，用来判断这个节点是从左子树还是右子树返回的
    while(p||!empty_stack(s)){
        if(p){
            Push(&s,p);
            p = p->lchild;
        }
        else{
            getTop(s,&p);
            // 如果栈顶元素没被访问（gettop（s，p）！= r）且右孩子不为空，将右孩子转执行1
            if(p->rchild && p->rchild!=r){
                p=p->rchild;
                Push(&s,p);
                p = p->lchild;
            }
            else{
                // 读栈顶元素，如果栈顶元素是刚刚被访问过的或者右孩子为空，就栈顶元素出栈并访问
                Pop(&s,&p);
                visit(p);
                r=p;
                p=null;
            }
        }//else
    }//while

}
```